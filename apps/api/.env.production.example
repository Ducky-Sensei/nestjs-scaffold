# Production Environment Configuration
# Copy this file to .env for production deployments and update with actual values

# Database Configuration
# REQUIRED: Set these to your actual production database credentials
DATABASE_HOST=your-database-host.example.com
DATABASE_PORT=5432
DATABASE_USER=your-production-db-user
DATABASE_PASSWORD=your-secure-password-here
DATABASE_NAME=your-production-db-name
DATABASE_URL=postgres://user:password@host:5432/database

# Database Connection Pool Configuration
# IMPORTANT: Tune these based on your database server's max_connections and application load
# Formula: (max_connections - superuser_reserved_connections) / number_of_app_instances
# Example: If PostgreSQL max_connections=100 and you have 3 app instances: 100/3 â‰ˆ 30 per instance
DATABASE_POOL_MAX=20                      # Maximum pool size (increase for high-traffic apps)
DATABASE_POOL_MIN=5                       # Minimum pool size (keep warm connections)
DATABASE_POOL_IDLE_TIMEOUT=30000          # Close idle connections after 30s (milliseconds)
DATABASE_POOL_CONNECTION_TIMEOUT=2000     # Connection timeout 2s (milliseconds)

# Application Configuration
NODE_ENV=production
PORT=3000

# Logging Configuration
# Production: Use 'warn' or 'error' to reduce noise
LOG_LEVEL=warn

# Auto-Migration Configuration
# IMPORTANT: Always false in production - run migrations manually
AUTO_MIGRATE=false

# Seed Database on Startup
# IMPORTANT: Always false in production
SEED_DATABASE=false

# Security Configuration - CORS
# CRITICAL: CORS_ORIGIN is strictly validated in production
#
# Requirements:
#   - NO wildcards (*) - app will fail to start
#   - NO localhost/127.0.0.1 addresses - app will fail to start
#   - MUST use HTTPS (https://) - app will fail to start
#   - Must be valid URLs
#
# Mobile app exceptions: capacitor:// and ionic:// schemes are allowed
#
# Examples:
#   Single origin:  CORS_ORIGIN=https://yourdomain.com
#   Multiple:       CORS_ORIGIN=https://yourdomain.com,https://app.yourdomain.com
#   With mobile:    CORS_ORIGIN=https://yourdomain.com,capacitor://localhost
#
CORS_ORIGIN=https://yourdomain.com

# Request body size limit
# Protects against DOS attacks via large payloads
# Format: number + unit (b, kb, mb, gb)
# Examples: 500kb, 1mb, 10mb
# Default: 1mb (suitable for most JSON APIs)
# Increase for APIs handling base64-encoded files or large data
BODY_SIZE_LIMIT=1mb

# Rate limiting configuration
# Adjust based on your traffic patterns
THROTTLE_TTL=60000
THROTTLE_LIMIT=100

# OpenTelemetry Configuration
OTEL_SERVICE_NAME=scaffold-service
# Use 'otlp' for production
OTEL_EXPORTER_TYPE=otlp
# Set to your OTLP collector endpoint
OTEL_EXPORTER_OTLP_ENDPOINT=https://your-otlp-endpoint.example.com/v1/traces

# Sentry Configuration
# RECOMMENDED: Enable Sentry for error tracking in production
SENTRY_ENABLED=true
# REQUIRED if SENTRY_ENABLED=true: Get this from your Sentry project settings
SENTRY_DSN=https://examplePublicKey@o0.ingest.sentry.io/0
SENTRY_ENVIRONMENT=production
# Use lower sample rates for high-traffic applications (0.1 = 10%)
SENTRY_TRACES_SAMPLE_RATE=0.1
SENTRY_PROFILES_SAMPLE_RATE=0.1

# Datadog Configuration
# RECOMMENDED: Enable Datadog for APM and monitoring in production
DATADOG_ENABLED=true
DATADOG_SERVICE_NAME=scaffold-service
DATADOG_ENV=production
DATADOG_VERSION=1.0.0
# Set to your Datadog Agent hostname
DATADOG_AGENT_HOST=localhost
DATADOG_AGENT_PORT=8126
DATADOG_RUNTIME_METRICS_ENABLED=true
# Enable profiling if needed (adds overhead)
DATADOG_PROFILING_ENABLED=false

# Prometheus Configuration
# RECOMMENDED: Enable Prometheus for free, self-hosted metrics monitoring
# Complements Datadog - use Prometheus for infrastructure metrics, Datadog for APM
PROMETHEUS_ENABLED=true
# Metrics endpoint path (will be scraped by Prometheus server)
PROMETHEUS_PATH=/metrics
# Enable default Node.js metrics (CPU, memory, GC, event loop, etc.)
PROMETHEUS_DEFAULT_METRICS=true

# Cache Configuration
# RECOMMENDED: Enable Redis caching in production for multi-instance deployments
# Benefits:
#   - Reduces database load by caching frequently accessed data
#   - Improves response times for repeated queries
#   - Enables distributed rate limiting across multiple app instances
#   - Shares cached data between application instances
CACHE_ENABLED=true
# Cache type: 'redis' is STRONGLY RECOMMENDED for production
# 'memory' only suitable for single-instance deployments (not horizontally scalable)
CACHE_TYPE=redis
# Redis connection settings
# REQUIRED: Set to your Redis instance hostname or IP
REDIS_HOST=redis
REDIS_PORT=6379
# CRITICAL: Use a strong password for Redis in production
# Generate with: openssl rand -base64 32
REDIS_PASSWORD=your-secure-redis-password-here
# Redis database number (0-15, keep default unless you have specific needs)
REDIS_DB=0
# Cache TTL (Time To Live) in seconds
# Balance between data freshness and performance
# Examples: 60 (1 min), 300 (5 min), 3600 (1 hour)
CACHE_TTL=300

# Authentication Configuration
# CRITICAL: JWT secret must be a strong random string in production
# Generate with: node -e "console.log(require('crypto').randomBytes(64).toString('hex'))"
JWT_SECRET=CHANGE-THIS-TO-A-RANDOM-SECRET-IN-PRODUCTION
# JWT token expiration (shorter in production for security)
JWT_EXPIRES_IN=7d
